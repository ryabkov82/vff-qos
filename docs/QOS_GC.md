# QoS Garbage Collection (tc GC)

## Назначение

`qos_gc_tc.sh` — это механизм фоновой очистки устаревших **per-user HTB классов**
и связанных с ними **fw-фильтров**, создаваемых системой QoS для Xray-пользователей.

GC предназначен для:

- предотвращения накопления тысяч неиспользуемых `tc class` / `tc filter`;
- сохранения производительности `tc` и сетевого стека ядра;
- обеспечения полностью **идемпотентной и безопасной** очистки;
- отсутствия влияния на активных пользователей и текущий трафик.

GC не участвует в обработке трафика в реальном времени и не находится в
основном follower-loop.

---

## Что очищается

Для каждого per-user `fw mark` GC может удалить:

- HTB классы:
  - uplink: `1:<mark>`
  - downlink: `2:<mark>`
- fw-фильтры, направляющие трафик в эти классы:
  - на WAN-интерфейсе;
  - на IFB-интерфейсе;
- **“висячие” fw-фильтры**, если соответствующий `classid` уже отсутствует.

---

## Критерии удаления

Per-user mark считается кандидатом на удаление, если одновременно выполняются
следующие условия:

### 1. Минимальный возраст

Класс существует дольше, чем:

```
QOS_GC_MIN_AGE_SEC
```

По умолчанию: **600 секунд (10 минут)**.

---

### 2. Отсутствие трафика (idle)

В течение времени:

```
QOS_GC_IDLE_SEC
```

не наблюдается увеличения счётчика `Sent bytes` ни в uplink, ни в downlink
HTB-классах.

По умолчанию: **14400 секунд (4 часа)**.

---

### 3. (Опционально) Отсутствие conntrack-сессий

Если включено:

```
QOS_GC_USE_CONNTRACK=1
```

GC дополнительно проверяет наличие активных conntrack-сессий с данным `fw mark`.
Если такие сессии существуют — удаление не выполняется.

---

## Что никогда не трогается

GC **гарантированно не удаляет**:

- корневые классы:
  - `1:1`
  - `2:1`
- дефолтные классы:
  - `1:fffe`
  - `2:fffe`
- активные per-user классы (есть трафик или conntrack-сессии);
- любые `tc` объекты вне QoS-иерархии роли `qos_per_user_xray`.

---

## Алгоритм работы

1. Загрузка конфигурации из `qos.env`.
2. Авто-детект WAN-интерфейса, если `WAN_DEV=auto`.
3. Очистка “висячих” fw-фильтров.
4. Сбор snapshot’а HTB-классов (UL/DL).
5. Обновление состояния (`state.tsv`).
6. Отбор кандидатов по `age` и `idle`.
7. (Опционально) проверка conntrack.
8. Удаление fw-фильтров и HTB-классов.
9. Логирование итогового summary.

---

## Хранение состояния

GC использует файл:

```
/var/lib/qos-gc/state.tsv
```

Формат:

```
<hex_mark> <first_seen> <last_seen> <ul_bytes> <dl_bytes>
```

---

## Переменные окружения

```env
QOS_GC_ENABLE=1
QOS_GC_MIN_AGE_SEC=600
QOS_GC_IDLE_SEC=14400
QOS_GC_USE_CONNTRACK=0
QOS_GC_DRY_RUN=0
```

---

## Интеграция с systemd

- `qos-gc.timer` — расписание запуска
- `qos-gc.service` — oneshot сервис

Управление осуществляется **только таймером**.

---

## Состояния роли (Ansible)

| qos_state  | Поведение GC |
|-----------|--------------|
| present   | таймер включён |
| disabled  | таймер отключён |
| absent    | таймер и файлы удалены |

---

## Диагностика

```bash
systemctl list-timers | grep qos-gc
journalctl -u qos-gc.service -n 200
QOS_GC_DRY_RUN=1 /usr/local/bin/qos_gc_tc.sh
```

---

## Почему GC вынесен отдельно

GC вынесен в отдельный скрипт и systemd timer, чтобы:

- не нагружать follower-loop;
- минимизировать влияние на CPU;
- упростить диагностику и сопровождение;
- сохранить предсказуемость работы QoS.
