---
# NOTE: verify.yml is "best effort" â€” never fails the play.
# This version matches the new Docker-safe nft runtime model (no /etc/nftables.conf includes, no nftables reload).

# --- nft runtime verifications (ct mark -> skb mark) ---
- name: QoS | Verify nft table exists (best effort)
  ansible.builtin.command: "nft list table {{ qos_nft_table_family }} {{ qos_nft_table_name }}"
  register: qos_nft_table_check
  changed_when: false
  failed_when: false
  when:
    - qos_nft_manage | bool
    - qos_state == "present"

- name: QoS | Verify prerouting chain exists (best effort)
  ansible.builtin.command: "nft -a list chain {{ qos_nft_table_family }} {{ qos_nft_table_name }} {{ qos_nft_chain_prerouting }}"
  register: qos_nft_chain_prerouting_check
  changed_when: false
  failed_when: false
  when:
    - qos_nft_manage | bool
    - qos_state == "present"

- name: QoS | Verify output chain exists (best effort)
  ansible.builtin.command: "nft -a list chain {{ qos_nft_table_family }} {{ qos_nft_table_name }} {{ qos_nft_chain_output }}"
  register: qos_nft_chain_output_check
  changed_when: false
  failed_when: false
  when:
    - qos_nft_manage | bool
    - qos_state == "present"

- name: QoS | Verify ctmark->fwmark rule present in prerouting (best effort)
  ansible.builtin.shell: |
    set -euo pipefail
    nft -a list chain {{ qos_nft_table_family }} {{ qos_nft_table_name }} {{ qos_nft_chain_prerouting }} \
      | grep -Fq "meta mark set ct mark"
  args:
    executable: /bin/bash
  register: qos_nft_rule_prerouting_check
  changed_when: false
  failed_when: false
  when:
    - qos_nft_manage | bool
    - qos_state == "present"

- name: QoS | Verify ctmark->fwmark rule present in output (best effort)
  ansible.builtin.shell: |
    set -euo pipefail
    nft -a list chain {{ qos_nft_table_family }} {{ qos_nft_table_name }} {{ qos_nft_chain_output }} \
      | grep -Fq "meta mark set ct mark"
  args:
    executable: /bin/bash
  register: qos_nft_rule_output_check
  changed_when: false
  failed_when: false
  when:
    - qos_nft_manage | bool
    - qos_state == "present"

# Optional: verify persistence unit exists/active (only when systemd is enabled)
- name: QoS | Verify vff-qos-nft service is active (best effort)
  ansible.builtin.command: "systemctl is-active vff-qos-nft.service" # noqa command-instead-of-module
  register: qos_nft_unit_active
  changed_when: false
  failed_when: false
  when:
    - qos_systemd_enable | bool
    - qos_nft_manage | bool
    - qos_state == "present"

- name: QoS | Verify vff-qos-nft service is enabled (best effort)
  ansible.builtin.command: "systemctl is-enabled vff-qos-nft.service" # noqa command-instead-of-module
  register: qos_nft_unit_enabled
  changed_when: false
  failed_when: false
  when:
    - qos_systemd_enable | bool
    - qos_nft_manage | bool
    - qos_state == "present"

# --- tc / IFB verifications (best effort) ---
# Keep your existing checks. Note: "ctinfo cpmark" is a different mechanism (tc act_ctinfo).
# If you no longer use act_ctinfo, you may remove this check or guard it by a dedicated variable.
- name: QoS | Verify ingress filter contains ctinfo cpmark (best effort)
  ansible.builtin.shell: |
    set -euo pipefail
    detect_wan_if() {
      ip -4 route show default 2>/dev/null \
        | awk '{for(i=1;i<=NF;i++) if($i=="dev"){print $(i+1); exit}}'
    }

    WAN="{{ qos_if_wan }}"
    if [[ -z "$WAN" || "$WAN" == "auto" ]]; then
      WAN="$(detect_wan_if || true)"
    fi

    [[ -n "${WAN:-}" ]] || exit 0
    tc filter show dev "$WAN" parent ffff: | grep -q "ctinfo cpmark"
  args:
    executable: /bin/bash
  register: qos_tc_cpmark_check
  changed_when: false
  failed_when: false
  when:
    - qos_tc_enable | bool
    - qos_state == "present"

- name: QoS | Verify IFB qdisc exists (best effort)
  ansible.builtin.command: "tc qdisc show dev {{ qos_if_ifb }}"
  register: qos_tc_ifb
  changed_when: false
  failed_when: false
  when:
    - qos_tc_enable | bool
    - qos_state == "present"

- name: QoS | Verify WAN qdisc exists (best effort)
  ansible.builtin.shell: |
    set -euo pipefail
    detect_wan_if() {
      ip -4 route show default 2>/dev/null \
        | awk '{for(i=1;i<=NF;i++) if($i=="dev"){print $(i+1); exit}}'
    }
    WAN="{{ qos_if_wan }}"
    if [[ -z "$WAN" || "$WAN" == "auto" ]]; then
      WAN="$(detect_wan_if || true)"
    fi
    [[ -n "${WAN:-}" ]] || exit 0
    tc qdisc show dev "$WAN"
  args:
    executable: /bin/bash
  register: qos_tc_wan
  changed_when: false
  failed_when: false
  when:
    - qos_tc_enable | bool
    - qos_state == "present"

# --- QoS GC verifications (best effort) ---
- name: QoS | Verify qos-gc timer is active/enabled (best effort)
  ansible.builtin.command: "systemctl is-active qos-gc.timer" # noqa command-instead-of-module
  register: qos_gc_timer_active
  changed_when: false
  failed_when: false
  when:
    - qos_systemd_enable | bool
    - qos_state == "present"
    - qos_gc_enable | default(true) | bool

- name: QoS | Verify qos-gc timer is enabled (best effort)
  ansible.builtin.command: "systemctl is-enabled qos-gc.timer" # noqa command-instead-of-module
  register: qos_gc_timer_enabled
  changed_when: false
  failed_when: false
  when:
    - qos_systemd_enable | bool
    - qos_state == "present"
    - qos_gc_enable | default(true) | bool

- name: QoS | Verify qos-gc script can run in DRY_RUN (best effort)
  ansible.builtin.command: "{{ qos_bin_dir }}/qos_gc_tc.sh"
  register: qos_gc_dryrun_exec
  changed_when: false
  failed_when: false
  environment:
    QOS_GC_DRY_RUN: "1"
  when:
    - qos_state == "present"
